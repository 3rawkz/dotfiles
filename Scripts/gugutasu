#!/usr/bin/env ruby

require 'fileutils'
require 'google/api_client'
require 'json'
require 'net/http'
require 'optparse'
require 'tzinfo'

module Gugutasu

  NAME = 'gugutasu'
  VERSION = '2016.02.01'

  def self.api_key
    @@api_key
  end

  def self.api_key=(api_key)
    @@client.key = @@api_key = api_key
  end

  def self.register_client(api_key)
    @@client =
      Google::APIClient.new(:application_name => 'GooglePlusArchiver',
                            :application_version => VERSION)
    @@api_key = @@client.key = api_key
    @@request_num = 0
    begin
      @@plus = @@client.discovered_api('plus')
    rescue Exception => e
      puts e
    end
  end

  def self.client_registered?
    defined? @@plus
  end

  def self.get_full_image_url(url)
    if url =~ /https:\/\/\w+\.googleusercontent\.com/
      if url =~ /\/s\d+\/[^\/]+$/ or url =~ /\/w\d+-h\d+\/[^\/]+$/ or url =~ /\/w\d+-h\d+-\w+\/[^\/]+$/
        url[0..url[0..(url.rindex('/') - 1)].rindex('/')] + 's0-d' + url[url.rindex('/')..-1]
      elsif url =~ /\/photo.jpg$/ and not url =~ /\/s0-d\/[^\/]+$/
        url[0..url.rindex('/')] + 's0-d' + url[url.rindex('/')..-1]
      else
        url
      end
    else
      url
    end
  end

  def self.save_activity(params)
    begin
      raise "Unregistered client." unless client_registered?
    rescue => e
      puts e.message
      return
    end

    index, activity_id, output_path, timezone =
      params[:index], params[:activity_id], (params[:output_path] or FileUtils.pwd), (params[:timezone].nil? ? 'Etc/UTC' : params[:timezone])

    response = @@client.execute(:api_method => @@plus.activities.get,
                                :parameters => {
                                  'activityId' => activity_id,
                                },
                                :authenticated => false)

    data = JSON.parse(response.body)

    name = data['actor']['displayName']
    url = data['url']
    content = data['object']['content']
    attachments = data['object']['attachments']

    published = data['published']
    tz = TZInfo::Timezone.get(timezone)
    published_date = tz.utc_to_local(DateTime.rfc3339(published)).strftime('%F')
    published_date_readable = tz.utc_to_local(DateTime.rfc3339(published)).strftime('%d %b %Y')
    published_time = tz.utc_to_local(DateTime.rfc3339(published)).strftime('%T')

    puts "\n[#{index+1}] Reading post by #{name}, published at #{published}"

    output_dir = File.join(output_path, name, published_date)
    FileUtils.mkdir_p output_dir
    output_base = File.join(output_dir, published_time)

    output_json = output_base + '.json'
    File.open(output_json, 'w').puts response.body

    output_md = output_base + '.pt'
    md = content.gsub(/<br \/>/, "\n")
    File.open(output_md, 'w') do |file|
      file.puts '---'
      file.puts "date: #{published_date_readable}"
      file.puts "url: #{url}"
      file.puts '---'
      file.puts md
    end
    puts "[#{index+1}] Post saved at #{output_md}"

    attachments.each do |attachment|
      if attachment['objectType'] == 'photo'
        image_id = attachment['id']
        image_url = get_full_image_url(attachment['fullImage']['url'])
        puts "[#{index+1}] Downloading image: #{image_url}"
        uri = URI.parse(URI.escape(image_url))
        http = Net::HTTP.new(uri.host, uri.port)
        if http.port == 443
          http.use_ssl = true
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        end
        image = http.get(uri.request_uri)

        begin
          image_filename = image.header['Content-Disposition'].match /filename="([^"]+)"/
          extname = image_filename[1].split('.')[-1]
        rescue
          extname = image.header['Content-Type'].split('/')[-1]
        end

        output_image = "#{output_base}.#{image_id}.#{extname}"
        File.open(output_image, 'w').puts image.body

      elsif attachment['objectType'] == 'album'
        image_id = attachment['id']
        thumbnails = attachment['thumbnails']
        if thumbnails
          thumbnails.each_index do |index|
            thumbnail = thumbnails[index]
            image_url = get_full_image_url(thumbnail['image']['url'])
            puts "[#{index+1}] Downloading image: #{image_url}"
            uri = URI.parse(URI.escape("#{image_url}"))
            http = Net::HTTP.new(uri.host, uri.port)
            if http.port == 443
              http.use_ssl = true
              http.verify_mode = OpenSSL::SSL::VERIFY_NONE
            end
            image = http.get(uri.request_uri)

            begin
              image_filename = image.header['Content-Disposition'].match /filename="([^"]+)"/
              extname = image_filename[1].split('.')[-1]
            rescue
              extname = image.header['Content-Type'].split('/')[-1]
            end

            output_image = "#{output_base}.#{image_id}[#{index}].#{extname}"
            File.open(output_image, 'w').puts image.body
          end
        end

      elsif attachment['objectType'] == 'video'
        video_id = attachment['id']
        video_url = attachment['url']
        puts "[#{index+1}] Downloading video: #{video_url}"
        system "you-get -o '#{output_base}.#{video_id}' #{video_url}"

      end
    end if attachments
  end

  def self.archive_user(params)
    begin
      raise "Unregistered client." unless client_registered?
    rescue => e
      puts e.message
      return
    end

    index, user_id, output_path, timezone =
      params[:index], params[:user_id], (params[:output_path] or FileUtils.pwd), (params[:timezone].nil? ? 'Etc/UTC' : params[:timezone])

    tmp_dir = output_path
    quiet = false
    video_downloader = 'you-get'
    response = nil

    # profile
    puts "##{@@request_num+=1} people.get ..." unless quiet
    response = @@client.execute(
      :api_method => @@plus.people.get,
      :parameters => {
        'collection' => 'public',
        'userId' => user_id
      },
      :authenticated => false
    )
    File.open("#{File.join(tmp_dir, 'profile.json')}", "w") do |f|
      f.puts response.body
    end

    user_display_name = JSON.parse(response.body)['displayName']
    next_page_token = nil
    page_num = 0

    loop do
      puts "##{@@request_num+=1} activities.list: page[#{page_num}] ..." unless quiet
      maxResults = 100
      loop do
        begin
          response = @@client.execute(
            :api_method => @@plus.activities.list,
            :parameters => {
              'collection' => 'public',
              'userId' => user_id,
              'maxResults' => maxResults.to_s,
              'pageToken' => next_page_token
            },
            :authenticated => false
          )
        rescue
          puts "##{@@request_num} Retrying activities.list: page[#{page_num}] ..." unless quiet
          next
        else
          break
        end
      end

      activities = JSON.parse(response.body)
      next_page_token = activities['nextPageToken']

      File.open("#{File.join(tmp_dir, 'posts')}[#{page_num}].json", "w") do |f|
        f.puts response.body
      end

      activities['items'].each do |item|
        activity_id = item['id']

        published = item['published']
        tz = TZInfo::Timezone.get(timezone)
        published_date = tz.utc_to_local(DateTime.rfc3339(published)).strftime('%F')
        published_date_readable = tz.utc_to_local(DateTime.rfc3339(published)).strftime('%d %b %Y')
        published_time = tz.utc_to_local(DateTime.rfc3339(published)).strftime('%T')
        puts "##{@@request_num}   #{published}" unless quiet

        output_dir = File.join(tmp_dir, published_date)
        FileUtils.mkdir_p output_dir
        output_base = File.join(output_dir, published_time)

        File.open("#{File.join(output_dir, activity_id)}.json", "w") do |f|
          f.puts item.to_json
        end

        if item['object'].key?('attachments')
          item['object']['attachments'].each do |attachment|
            if attachment['objectType'] == 'photo'
              # Download full-size image
              begin
                image = attachment['fullImage']
                image_url = get_full_image_url(image['url'])
                puts "##{@@request_num}     Fetching attachment: #{image_url} ..." unless quiet
                uri = URI.parse(URI.escape("#{image_url}"))
                http = Net::HTTP.new(uri.host, uri.port)
                if http.port == 443
                  http.use_ssl = true
                  http.verify_mode = OpenSSL::SSL::VERIFY_NONE
                end
                data = http.get(uri.request_uri)
                image_ext = uri.request_uri.split("/")[-1].split(".")[-1]
                image_ext = nil if image_ext.length > 4

                #<< attachment
                File.open("#{File.join(output_dir, activity_id)}_#{attachment['id']}.#{image_ext}", "w").puts data.body
              rescue
                image = attachment['image']
                image_url = get_full_image_url(image['url'])
                puts "##{@@request_num}     Fetching attachment: #{image_url} ..." unless quiet
                uri = URI.parse(URI.escape("#{image_url}"))
                http = Net::HTTP.new(uri.host, uri.port)
                if http.port == 443
                  http.use_ssl = true
                  http.verify_mode = OpenSSL::SSL::VERIFY_NONE
                end
                data = http.get(uri.request_uri)
                image_ext = uri.request_uri.split("/")[-1].split(".")[-1]
                image_ext = nil if image_ext.length > 4

                #<< attachment
                File.open("#{File.join(output_dir, activity_id)}_#{attachment['id']}.#{image_ext}", "w").puts data.body
              end

            elsif attachment['objectType'] == 'album'
              # Download full-size thumbnails
              thumbnails = attachment['thumbnails']
              if thumbnails
                thumbnails.each_index do |index|
                  thumbnail = thumbnails[index]
                  image = thumbnail['image']
                  image_url = get_full_image_url(image['url'])
                  puts "##{@@request_num}     Fetching attachment: #{image_url} ..." unless quiet
                  uri = URI.parse(URI.escape("#{image_url}"))
                  http = Net::HTTP.new(uri.host, uri.port)
                  if http.port == 443
                    http.use_ssl = true
                    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
                  end
                  data = http.get(uri.request_uri)
                  image_ext = uri.request_uri.split("/")[-1].split(".")[-1]
                  image_ext = nil if image_ext.length > 4

                  #<< attachment
                  File.open("#{File.join(output_dir, activity_id)}_#{attachment['id']}[#{index}].#{image_ext}", "w").puts data.body
                end
              end

            elsif attachment['objectType'] == 'video'
              # Download preview image
              image = attachment['image']
              image_url = get_full_image_url(image['url'])
              puts "##{@@request_num}     Fetching attachment: #{image_url} ..." unless quiet
              uri = URI.parse(URI.escape("#{image_url}"))
              http = Net::HTTP.new(uri.host, uri.port)
              if http.port == 443
                http.use_ssl = true
                http.verify_mode = OpenSSL::SSL::VERIFY_NONE
              end
              data = http.get(uri.request_uri)
              image_ext = 'gif'

              extname = data.header['Content-Type'].split('/')[-1]

              #<< attachment
              File.open("#{File.join(output_dir, activity_id)}_#{attachment['id']}.#{extname}", "w").puts data.body

              # Download video
              if attachment['url'] !~ /^http:\/\/www.youtube.com\//
                puts "##{@@request_num}     Downloading video: #{attachment['url']} ..." unless quiet
                FileUtils.mkdir("#{File.join(output_dir, 'video')}")
                Dir.chdir("#{File.join(output_dir, 'video')}") do
                  if system("#{video_downloader} #{attachment['url']}")
                    Dir.glob("*").each do |video|
                      FileUtils.mv(video, "#{File.join(output_dir, activity_id)}_#{attachment['id']}_#{attachment['displayName'].split('/').join}.#{video.split('.')[-1]}")
                    end
                  else
                    puts "##{@@request_num}     Video downloader failed. Download aborted."
                  end
                end
                FileUtils.rm_r("#{File.join(output_dir, 'video')}")
              end
            end
          end
        end

      end

      break unless next_page_token
      page_num += 1
    end

  end

end



if __FILE__ == $0
  options = {}
  OptionParser.new do |opts|
    opts.banner = 'Usage: '

    opts.on('-a', '--api-key [API_KEY]', 'Specify the Google API key') do |api_key|
      options[:api_key] = api_key
    end

    opts.on('-o', '--output-path [OUTPUT_PATH]', 'Output path (the current directory by default)') do |output_path|
      options[:output_path] = output_path
    end

    opts.on('-t', '--timezone [TIMEZONE]', 'Time zone') do |timezone|
      options[:timezone] = timezone
    end

    opts.on('-x', '--proxy [PROXY]', 'Use proxy on given port') do |proxy|
      options[:proxy] = proxy
    end

    opts.on('-V', '--version', 'Display current version') do
      puts "#{Gugutasu::NAME} #{Gugutasu::VERSION}"
      exit 0
    end
  end.parse!

  options[:api_key] = ENV['GOOGLE_API_KEY'] if
    not options[:api_key]
  options[:output_path] = ENV['GOOGLE_ARCHIVE_PATH'] if
    not options[:output_path]
  options[:timezone] = ENV['GOOGLE_ARCHIVE_TIMEZONE'] if
    not options[:timezone]

  if not options[:api_key]
    puts 'You must specify your Google API key (-a).'
    exit 0
  end

  Gugutasu::register_client(options[:api_key])
  if not Gugutasu::client_registered?
    puts 'Client registration failed.'
    exit 0
  end

  ARGV.each_index do |index|
    url = ARGV[index]
    uri = URI.parse(url)

    if options[:proxy]
      proxy_addr, proxy_port = options[:proxy].split ':'
      http = Net::HTTP.new(uri.host, uri.port, proxy_addr, proxy_port)
    else
      http = Net::HTTP.new(uri.host, uri.port)
    end

    if http.port == 443
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    end

    response = http.get uri.request_uri
    # Handle Google+ custom URL redirection
    while response.code == '302'
      response = http.get response['location']
    end

    # Handle Google+ album URL
    if uri.request_uri.start_with? '/photos/' or uri.request_uri.start_with? '/u/0/photos/'
      post_request_uri = '/' + response.body.match(/"([^"\/]+\/posts\/[^"]+)"/)[1]

      response = http.get post_request_uri
      # Handle Google+ custom URL redirection
      if response.code == '302'
        response = http.get response['location']
      end
    end

    if uri.request_uri.split('/').length > 2
      activity_id = response.body.match(/<div id="update-([^"]+)"/)[1]
      Gugutasu::save_activity(:index => index,
                              :activity_id => activity_id,
                              :output_path => options[:output_path],
                              :timezone => options[:timezone])
    else
      user_id = uri.request_uri.split('/')[1]
      Gugutasu::archive_user(:index => index,
                             :user_id => user_id,
                             :output_path => options[:output_path],
                             :timezone => options[:timezone])
    end

  end
end
